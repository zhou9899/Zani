const superagent = require("superagent");

class Nsfw {
  constructor() {
    this.version = require("../package.json").version;
    this._getRandomAnimeAPI = this._getRandomAnimeAPI.bind(this);
    this.anime = new Proxy({}, {
      get: (_, tag) => {
        return async () => this._getRandomAnimeAPI(tag.toString());
      }
    });

    this.real = {
      boobs: this._realBoobs.bind(this),
      ass: () => this._onrender("ass"),
      pussy: () => this._onrender("pussy"),
      thigh: () => this._onrender("thigh"),
      gonewild: () => this._nekorbot("gonewild"),
      sixtynine: () => this._onrender("sixtynine"),
      anal: () => this._onrender("anal"),
      bdsm: () => this._onrender("bdsm"),
      black: () => this._onrender("black"),
      easter: () => this._onrender("easter"),
      bottomless: () => this._onrender("bottomless"),
      blowjob: () => this._onrender("suck"),
      collared: () =>  this._onrender("collared"),
      cum: () => this._onrender("cum"),
      cumsluts: () => this._onrender("cumsluts"),
      feet: () => this._onrender("feet"),
      finger: () => this._onrender("finger"),
      fuck: () => this._onrender("fuck"),
      group: () => this._onrender("group"),
      lick: () => this._onrender("lick"),
      phgif: () => this._onrender("phgif"),
      tattoo: () => this._onrender("tattoo"),
      tiny: () => this._onrender("tiny"),
      toys: () => this._onrender("toys"),
      xmas: () => this._onrender("xmax")
    }; 
  }
  async _onrender(tag) {
    const response = await fetch(`https://nsfwhub.onrender.com/nsfw?type=${tag}`);
    const data = await response.json();
    return data.image.url
  }
  async _realBoobs() {
    const id = [Math.floor(Math.random() * 10930)];
    const res = await superagent.get(`http://api.oboobs.ru/boobs/${id}`);
    const preview = res.body[0]["preview"];
    return `http://media.oboobs.ru/${preview}`;
  }
  async _nekorbot(tag) {

    const url = `https://nekobot.xyz/api/image?type=${tag}`;

    try {
      const response = await fetch(url);
      const data = await response.json();
      return data.success ? data.message : null;
    } catch {
      return null;
    }
  }

  // --- API Backends ---

  async nekohbot(tag) {
    const valid = ["ass", "hentai", "neko", "kitsune", "anal", "thigh", "boobs"];
    if (!valid.includes(tag)) return null;

    const remap = {
      ass: "hass",
      neko: "hneko",
      kitsune: "hkitsune",
      anal: "hanal",
      thigh: "hthigh",
      boobs: "hboobs"
    };

    const queryTag = remap[tag] || tag;
    const url = `https://nekobot.xyz/api/image?type=${queryTag}`;

    try {
      const response = await fetch(url);
      const data = await response.json();
      return data.success ? data.message : null;
    } catch {
      return null;
    }
  }

  async waifuim(tag) {
    const valid = ["ass", "hentai", "milf", "oral", "paizuri", "ecchi", "ero"];
    if (!valid.includes(tag)) return null;

    const params = new URLSearchParams({
      included_tags: tag,
      height: ">=2000"
    });

    try {
      const response = await fetch(`https://api.waifu.im/search?${params}`);
      const data = await response.json();
      return data.images?.[0]?.url || null;
    } catch {
      return null;
    }
  }

  async waifupic(tag) {
    const valid = ["waifu", "neko", "trap", "blowjob"];
    if (!valid.includes(tag)) return null;

    try {
      const response = await fetch(`https://api.waifu.pics/nsfw/${tag}`);
      const data = await response.json();
      return data.url;
    } catch {
      return null;
    }
  }

  async purrbot(tag) {
    const valid = ['anal', 'blowjob', 'cum', 'fuck', 'neko', 'kiss', 'pussylick', 'solo', 'yuri'];
    if (!valid.includes(tag)) return null;

    try {
      const response = await fetch(`https://api.purrbot.site/v2/img/nsfw/${tag}/gif`);
      const data = await response.json();
      return !data.error ? data.link : null;
    } catch {
      return null;
    }
  }

  // --- Central Random API ---
  async _getRandomAnimeAPI(tag) {
    const apiMap = {
      waifuim: ["ass", "hentai", "milf", "oral", "paizuri", "ecchi", "ero"],
      waifupic: ["waifu", "neko", "trap", "blowjob"],
      nekohbot: ["ass", "hentai", "neko", "kitsune", "anal", "boobs", "thigh"],
      purrbot: ['anal', 'blowjob', 'cum', 'fuck', 'neko', 'kiss', 'pussylick', 'solo', 'yuri']
    };
    const apiFns = {
      waifuim: this.waifuim.bind(this),
      waifupic: this.waifupic.bind(this),
      nekohbot: this.nekohbot.bind(this),
      purrbot: this.purrbot.bind(this)
    };
    const eligibleApis = Object.entries(apiMap)
      .filter(([_, tags]) => tags.includes(tag))
      .map(([name]) => apiFns[name]);

    if (eligibleApis.length === 0) {
      return `No APIs support the tag: ${tag}`;
    }

    // Shuffle and try each eligible API until one works
    const shuffled = eligibleApis.sort(() => Math.random() - 0.5);

    for (const api of shuffled) {
      const result = await api(tag);
      if (result && result.startsWith("http")) {
        return result;
      }
    }

    return "No valid API could return an image for tag: " + tag;
  }
}

module.exports = Nsfw;
