// ============================================
// index.js — WhatsApp Bot (Git + Termux Session)
// ============================================

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import dotenv from "dotenv";
import { makeWASocket, useMultiFileAuthState, DisconnectReason, Browsers, jidDecode } from "@whiskeysockets/baileys";
import qrcodeTerminal from "qrcode-terminal";

dotenv.config();
const __dirname = path.dirname(fileURLToPath(import.meta.url));

// ==================== BOT LOCK ====================
const LOCK_FILE = path.join(__dirname, "bot.lock");
let currentSocket = null;
let isConnecting = false;
let isShuttingDown = false;

// Prevent multiple instances
if (fs.existsSync(LOCK_FILE)) {
  try {
    const pid = parseInt(fs.readFileSync(LOCK_FILE, "utf8"));
    process.kill(pid, 0);
    console.error(`❌ Another bot instance is running (PID: ${pid})`);
    process.exit(1);
  } catch {
    fs.unlinkSync(LOCK_FILE);
  }
}
fs.writeFileSync(LOCK_FILE, process.pid.toString());

// ==================== CLEANUP ====================
const cleanup = () => {
  if (fs.existsSync(LOCK_FILE) && parseInt(fs.readFileSync(LOCK_FILE, "utf8")) === process.pid) {
    fs.unlinkSync(LOCK_FILE);
    console.log("🧹 Cleanup completed");
  }
};

const shutdown = (signal) => {
  if (isShuttingDown) return;
  isShuttingDown = true;
  console.log(`\n🛑 Received ${signal}, shutting down...`);
  cleanup();
  if (currentSocket?.ws?.readyState === 1) currentSocket.ws.close();
  setTimeout(() => process.exit(0), 1000);
};

process.on("exit", cleanup);
process.on("SIGINT", () => shutdown("SIGINT"));
process.on("SIGTERM", () => shutdown("SIGTERM"));
process.on("uncaughtException", err => {
  console.error("💥 Uncaught Exception:", err);
  cleanup();
  process.exit(1);
});

// ==================== START BOT ====================
async function startBot() {
  if (isConnecting || isShuttingDown) return;
  isConnecting = true;
  console.log("🚀 Connecting to WhatsApp...");

  try {
    const { state, saveCreds } = await useMultiFileAuthState(path.join(__dirname, "auth_info"));

    const sock = makeWASocket({
      auth: state,
      browser: Browsers.windows("Chrome"),
      markOnlineOnConnect: false,
      syncFullHistory: false,
      printQRInTerminal: false,
      keepAliveIntervalMs: 25000,
      connectTimeoutMs: 45000,
      maxRetries: 3
    });

    currentSocket = sock;
    sock.ev.on("creds.update", saveCreds);

    // --- Safe sendMessage wrapper ---
    const originalSendMessage = sock.sendMessage.bind(sock);
    sock.sendMessage = async (jid, message, ...args) => {
      try {
        if (!jid || typeof jid !== "string") {
          console.warn("⚠️ Invalid JID:", jid);
          return;
        }
        const decoded = jidDecode(jid);
        if (!decoded?.user) {
          console.warn("⚠️ JID decode failed:", jid);
          return;
        }
        return await originalSendMessage(jid, message, ...args);
      } catch (err) {
        console.error("❌ sendMessage error:", err.message);
      }
    };

    sock.ev.on("connection.update", async ({ connection, lastDisconnect, qr }) => {
      if (qr) {
        qrcodeTerminal.generate(qr, { small: true });
        console.log("📱 Scan the QR to connect.");
      }

      if (connection === "open") {
        console.log("✅ Connected!");
        isConnecting = false;

        try { await sock.sendPresenceUpdate("available"); } catch {}

        const [{ loadCommands }, { handleMessages }] = await Promise.all([
          import("./handlers/commandLoader.js"),
          import("./handlers/messageHandler.js"),
        ]);

        await loadCommands(sock, path.join(__dirname, "commands"));
        handleMessages(sock);
        console.log("🎉 Bot ready!");
      }

      if (connection === "close") {
        isConnecting = false;
        const code = lastDisconnect?.error?.output?.statusCode;
        console.log(`❌ Connection closed. Code: ${code || "unknown"}`);
        if (code === DisconnectReason.loggedOut)
          fs.rmSync(path.join(__dirname, "auth_info"), { recursive: true, force: true });

        if (!isShuttingDown)
          setTimeout(startBot, code === DisconnectReason.loggedOut ? 3000 : 10000);
      }

      if (connection === "connecting")
        console.log("🔄 Reconnecting...");
    });
  } catch (err) {
    console.error("❌ Startup error:", err.message);
    isConnecting = false;
    if (!isShuttingDown) setTimeout(startBot, 10000);
  }
}

// ==================== INITIALIZE ====================
console.log("🤖 WhatsApp Bot Starting...");
startBot();

// ==================== AUTO-RESTART ====================
setInterval(() => {
  if (!isConnecting && !isShuttingDown && currentSocket?.ws?.readyState === 1) {
    console.log("🔄 Scheduled maintenance restart...");
    currentSocket.ws.close();
  }
}, 6 * 60 * 60 * 1000); // every 6 hours
